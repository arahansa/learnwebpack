<!DOCTYPE html>
<html>

<head>

<meta charset="utf-8">
<title>webpack-dev-server</title>

<!-- SEO -->
<meta content="summary" name="twitter:card"/>
<meta content="@arahansa" name="twitter:site"/>
<meta name="twitter:title" content="webpack dev server 한 페이지 번역"/>
<meta name="twitter:description" content="webpack dev server 한 페이지 번역"/>
<meta name="twitter:creator" content="@arahansa"/>
<meta name="twitter:image:src" content="images/me.jpg"/>

<meta property="og:title" content="webpack dev server 한 페이지 번역"/>
<meta property="og:image" content="images/me.jpg"/>
<meta property="og:description" content="webpack dev server 한 페이지 번역"/>

<meta content="article" property="og:type"/>
<!-- //SEO -->

<style type="text/css">
body {
  font-family: Helvetica, arial, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  padding-top: 10px;
  padding-bottom: 10px;
  background-color: white;
  padding: 30px; }

body > *:first-child {
  margin-top: 0 !important; }
body > *:last-child {
  margin-bottom: 0 !important; }

a {
  color: #4183C4; }
a.absent {
  color: #cc0000; }
a.anchor {
  display: block;
  padding-left: 30px;
  margin-left: -30px;
  cursor: pointer;
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0; }

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
  cursor: text;
  position: relative; }

h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor {
  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA09pVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoMTMuMCAyMDEyMDMwNS5tLjQxNSAyMDEyLzAzLzA1OjIxOjAwOjAwKSAgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OUM2NjlDQjI4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OUM2NjlDQjM4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo5QzY2OUNCMDg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo5QzY2OUNCMTg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PsQhXeAAAABfSURBVHjaYvz//z8DJYCRUgMYQAbAMBQIAvEqkBQWXI6sHqwHiwG70TTBxGaiWwjCTGgOUgJiF1J8wMRAIUA34B4Q76HUBelAfJYSA0CuMIEaRP8wGIkGMA54bgQIMACAmkXJi0hKJQAAAABJRU5ErkJggg==) no-repeat 10px center;
  text-decoration: none; }

h1 tt, h1 code {
  font-size: inherit; }

h2 tt, h2 code {
  font-size: inherit; }

h3 tt, h3 code {
  font-size: inherit; }

h4 tt, h4 code {
  font-size: inherit; }

h5 tt, h5 code {
  font-size: inherit; }

h6 tt, h6 code {
  font-size: inherit; }

h1 {
  font-size: 28px;
  color: black; }

h2 {
  font-size: 24px;
  border-bottom: 1px solid #cccccc;
  color: black; }

h3 {
  font-size: 18px; }

h4 {
  font-size: 16px; }

h5 {
  font-size: 14px; }

h6 {
  color: #777777;
  font-size: 14px; }

p, blockquote, ul, ol, dl, li, table, pre {
  margin: 15px 0; }

hr {
  background: transparent url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC) repeat-x 0 0;
  border: 0 none;
  color: #cccccc;
  height: 4px;
  padding: 0;
}

body > h2:first-child {
  margin-top: 0;
  padding-top: 0; }
body > h1:first-child {
  margin-top: 0;
  padding-top: 0; }
  body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0; }
body > h3:first-child, body > h4:first-child, body > h5:first-child, body > h6:first-child {
  margin-top: 0;
  padding-top: 0; }

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0; }

h1 p, h2 p, h3 p, h4 p, h5 p, h6 p {
  margin-top: 0; }

li p.first {
  display: inline-block; }
li {
  margin: 0; }
ul, ol {
  padding-left: 30px; }

ul :first-child, ol :first-child {
  margin-top: 0; }

dl {
  padding: 0; }
  dl dt {
    font-size: 14px;
    font-weight: bold;
    font-style: italic;
    padding: 0;
    margin: 15px 0 5px; }
    dl dt:first-child {
      padding: 0; }
    dl dt > :first-child {
      margin-top: 0; }
    dl dt > :last-child {
      margin-bottom: 0; }
  dl dd {
    margin: 0 0 15px;
    padding: 0 15px; }
    dl dd > :first-child {
      margin-top: 0; }
    dl dd > :last-child {
      margin-bottom: 0; }

blockquote {
  border-left: 4px solid #dddddd;
  padding: 0 15px;
  color: #777777; }
  blockquote > :first-child {
    margin-top: 0; }
  blockquote > :last-child {
    margin-bottom: 0; }

table {
  padding: 0;border-collapse: collapse; }
  table tr {
    border-top: 1px solid #cccccc;
    background-color: white;
    margin: 0;
    padding: 0; }
    table tr:nth-child(2n) {
      background-color: #f8f8f8; }
    table tr th {
      font-weight: bold;
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr td {
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr th :first-child, table tr td :first-child {
      margin-top: 0; }
    table tr th :last-child, table tr td :last-child {
      margin-bottom: 0; }

img {
  max-width: 100%; }

span.frame {
  display: block;
  overflow: hidden; }
  span.frame > span {
    border: 1px solid #dddddd;
    display: block;
    float: left;
    overflow: hidden;
    margin: 13px 0 0;
    padding: 7px;
    width: auto; }
  span.frame span img {
    display: block;
    float: left; }
  span.frame span span {
    clear: both;
    color: #333333;
    display: block;
    padding: 5px 0 0; }
span.align-center {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-center > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: center; }
  span.align-center span img {
    margin: 0 auto;
    text-align: center; }
span.align-right {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-right > span {
    display: block;
    overflow: hidden;
    margin: 13px 0 0;
    text-align: right; }
  span.align-right span img {
    margin: 0;
    text-align: right; }
span.float-left {
  display: block;
  margin-right: 13px;
  overflow: hidden;
  float: left; }
  span.float-left span {
    margin: 13px 0 0; }
span.float-right {
  display: block;
  margin-left: 13px;
  overflow: hidden;
  float: right; }
  span.float-right > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: right; }

code, tt {
  margin: 0 2px;
  padding: 0 5px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px; }

pre code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent; }

.highlight pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }

pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }
  pre code, pre tt {
    background-color: transparent;
    border: none; }

sup {
    font-size: 0.83em;
    vertical-align: super;
    line-height: 0;
}
* {
	-webkit-print-color-adjust: exact;
}
@media screen and (min-width: 914px) {
    body {
        width: 854px;
        margin:0 auto;
    }
}
@media print {
	table, pre {
		page-break-inside: avoid;
	}
	pre {
		word-wrap: break-word;
	}
}
</style>


</head>

<body>

<p><code>webpack-dev-server</code> 는 작은 Node.js Express 서버로 , <code>webpakc-dev-middleware</code>를 사용하여 웹팩번들 서버를 제공합니다.. 이것은 또한 Sock.js를 통하여 서버에 접속하는 작은 런타임을 제공합니다.</p>

<p>서버는 이벤트들에 반응하는 편집상태(개발되는 상태)에 관한 정보를  클라이언트에게 제공하며, 필요에 따라서 여러가지 모드를 선택할 수 있습니다.</p>

<div><pre><code class="language-none">var path = require(&quot;path&quot;);
module.exports = {
  entry: {
    app: [&quot;./app/main.js&quot;]
  },
  output: {
    path: path.resolve(__dirname, &quot;build&quot;),
    publicPath: &quot;/assets/&quot;,
    filename: &quot;bundle.js&quot;
  }
};
</code></pre></div>

<p>당신은 <code>app</code>폴더를 당신의 초기 엔트리 포인트로 설정할 수  있습니다. 이 엔트리포인트에서 <code>bundle.js</code>를 번들링하여  <code>build</code>폴더에 가져다가 놓을 것입니다. </p>

<p><strong>NOTE</strong> : webpack-dev-server 는 분리된 NPM 패키지입니다. 당신은 <code>npm install webpack-dev-server</code> 로 설치할 수 가 있습니다. </p>

<h2 id="toc_0">Content Base</h2>

<p>웹팩개발서버는 특정한 content base를 지정해주지 않는 이상 현재 디렉터리의 파일들을 serving 할 것입니다. </p>

<div><pre><code class="language-none">$ webpack-dev-server --content-base build/</code></pre></div>

<p>이러한 설정을 통해서 웹팩개발서버는 당신의 <code>build</code>폴더에 있는 정적 자원들을 서빙할 것입니다. 웹팩개발서버가 당신의 소스파일들을 감시하고, 그것들이 변경될때마다 번들을 재컴파일할 것입니다.</p>

<p>수정된 번들은 <code>publicPath</code>에 설정된 상대경로의 메모리로부터 serve될 것입니다. 수정된 번들은 당신이 설정한 <code>output</code>디렉터리에 쓰여지지 않을 것입니다. 번들이 이미 같은 URL 경로에 있다면 메모리의 번들이 우선권을 기본적으로 우선권을 가지게 됩니다.</p>

<p>당신의 번들파일을 불러오기 위해, <code>bundle</code> 폴더에서 정적으로 제공될 <code>index.html</code>을 만들 필요가 있습니다.
여기 예제가 있습니다.</p>

<div><pre><code class="language-none">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;script src=&quot;assets/bundle.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre></div>

<p>기본적으로 당신의 앱을 실행시키기 위하여 <code>localhost:8080</code>에 접속합니다만 여기 예제에서 <code>publicPath</code>를 사용하여서 <code>localhost:8080/assets/</code>로 가게 됩니다.</p>

<h2 id="toc_1">자동적 갱신 Refresh</h2>

<p>웹팩개발서버는 페이지를 자동으로 갱신하기 위한 여러가지 모드를 제공합니다.</p>

<p><strong>Iframe 모드</strong> : <code>iframe</code>안에 페이지가 내장되어서 바뀔때마다 다시 불러와집니다.
<strong>Inline 모드</strong> : 작은 웹팩개발서버 클라이언트엔트리가 번들에 추가가 되어서 바뀔때마다 페이지를 갱신합니다.</p>

<p>각각의 모듈은 또한 <strong>Hot Module Replacement</strong> 를 지원하는데 핫모듈대체에서 번들은 변경이 일어났을 때알아차릴 수 있습니다. 핫모듈대체 런타임은 실행되는 앱에 모듈들을 업데이트하고서 그것들을 주입할 수가 있게 됩니다.</p>

<h3 id="toc_2">IFrame 모드</h3>

<p>아이프레임 모드를 사용하기 위하여 추가적인 설정이 필요하지 않습니다. 단지  <code>http://«host»:«port»/webpack-dev-server/«path»</code> 를 브라우저에다가 치면 됩니다.</p>

<ul>
<li>설정이 필요하지 않습니다.</li>
<li>당신의 앱의 단에 정보를 나타내는 바가 생깁니다.</li>
<li>app 의 URL변경이 브라우저의 URL 바에 반영되지 않습니다.</li>
</ul>

<h3 id="toc_3">Inline 모드</h3>

<p>인라인모드를 사용하기 위해서</p>

<ul>
<li><code>--inline</code>을 커맨드라인에 입력하거나</li>
<li><code>webpack.config.js</code>에 <code>devServer : { inline: true}</code>를 입력하면 됩니다.</li>
</ul>

<p>이것들은 웹팩 설정에 웹팩개발서버 클라이언트 엔프리 포인트를 추가하게 됩니다. URL에 필요한 변경사항은 없습니다. 단지 브라우저에 <code>http://«host»:«port»/«path»</code>를 치면 됩니다. </p>

<p>위의 설정이라면 <code>http://localhost:8080/index.html</code>.</p>

<ul>
<li>커맨드라인 플래그가 필요합니다.</li>
<li>브라우저 로그에 상태 정보</li>
<li>앱의 URL 변경이 브라우저의 URL바에 반영됩니다.</li>
</ul>

<h4 id="toc_4">노드.js API와 inline 모드</h4>

<p>웹팩개발서버 설정에는 <code>inline:true</code>라는 설정이 없습니다. 왜냐하면 웹팩개발서버 모듈은 웹팩설정에 접근할 수 있지 않기 때문입니다. 대신에 웹팩설정에 웹팩개발서버 클라이언트 엔프리 포인트를 반드시 추가해야합니다.</p>

<p>이러한 것을 하기 위해, 단순히 다음의 엔프리포인트를 추가해보세요. <code>webpack-dev-server/client?http://«path»:«port»/</code></p>

<p>다음의 설정 : </p>

<div><pre><code class="language-none">var config = require(&quot;./webpack.config.js&quot;);
config.entry.app.unshift(&quot;webpack-dev-server/client?http://localhost:8080/&quot;);
var compiler = webpack(config);
var server = new WebpackDevServer(compiler, {...});
server.listen(8080);</code></pre></div>

<p>HTML에서의 inline 모드
HTML 페이지에 웹팩개발서버 클라이언트 스크립트에 대한 참조를 더하기 위한 옵션도 있습니다. </p>

<div><pre><code class="language-none">&lt;script src=&quot;http://localhost:8080/webpack-dev-server.js&quot;&gt;&lt;/script&gt;</code></pre></div>

<h4 id="toc_5">Hot Module Replacement (핫 모듈 대체로 부르기로;;)</h4>

<p>웹팩개발서버와 핫 모듈 대체를 활성화하기 위해 커맨드 라인에 <code>--hot</code>옵션을 지정할 수가 있습니다. 
이것은 웹팩 설정에 핫모듈대체플러그인을 추가합니다.</p>

<p>웹팩개발서버와 핫모듈대체를 사용하는 가장 쉬운 방법은 인라인모드를 사용하는 것입니다.</p>

<h5 id="toc_6">CLI에서 인라인모드를 통한 핫모듈대체</h5>

<p>특별히 필요한 것 없이 <code>--inline --hot</code> 이 연관된 일을 자동으로 처리해줍니다. 웹팩개발서버의 CLI가 자동으로 당신의 설정에 특정 <code>webpack/hot/dev-server</code> 를 추가해줄 것입니다.</p>

<p>단지 <code>http://«host»:«port»/«path»</code> 에 들어가보고 마법이 일어나는 것을 보세요. </p>

<p>당신은 브라우저 로그에서 다음과 같은 로그를 볼 수 있을 겁니다.</p>

<div><pre><code class="language-none">[HMR] Waiting for update signal from WDS...
[WDS] Hot Module Replacement enabled.</code></pre></div>

<p><code>[HMR]</code>로 시작하는 메시지들은 <code>webpack/hot/dev-server</code> 모듈로부터 왔습니다. <code>[WDS]</code>로 시작하는 메시지들은 웹팩 개발서버 클라이언트로부터 왔습니다. </p>

<p>정확한 <code>output.publicPath</code>를 지정해주는 것이 중요합니다. 그렇지 않으면 핫모듈 업데이트 청크들이  업데이트되지 않습니다. </p>

<h5 id="toc_7">node.js API와 핫모듈 대체</h5>

<p>인라인모드와 비슷하게, 유저는 반드시 웹팩 설정을 좀 고쳐야 합니다. 
세 가지의 수정이 필요합니다</p>

<ul>
<li>웹팩 설정에 엔트리 포인트를 추가해줄 필요가 있습니다.<br></li>
<li>웹팩설정에 <code>new webpack.HotModuleReplacementPlugin()</code>를 추가해줘야합니다.</li>
<li>웹팩개발서버 설정에 <code>hot: true</code>를 설정해줘서 서버에 HMR을 활성화시켜야합니다. </li>
</ul>

<p>설정은 다음과 같습니다. </p>

<div><pre><code class="language-none">var config = require(&quot;./webpack.config.js&quot;);
config.entry.app.unshift(&quot;webpack-dev-server/client?http://localhost:8080/&quot;, &quot;webpack/hot/dev-server&quot;);
var compiler = webpack(config);
var server = new webpackDevServer(compiler, {
  hot: true
  ...
});
server.listen(8080);</code></pre></div>

<h4 id="toc_8">“safe write” 를 지원하는 IDE/에디터로 작업하기</h4>

<p>많은 에디터가 “safe write” 속성을 지원하고 이것이 기본설정이라는 것을 생각해보면, 이것은 개발서버가 파일들을 올바르게 감시하는 것을 못하게 합니다. &quot;Safe write&quot;는 변경된 내용이 실제 파일에 직접적으로 바로 저장되지 않고 일시적인 파일에 일시적으로 저장되어서 저장작업이 성공적으로 완료되었을 때 실제 파일을 바꾸는 것을 의미합니다. 이러한 행동은 실제 파일이 지워지기 때문에 파일 감시기가 추적을 하지 못하게 합니다. 이러한 문제를 방지하기 위하여 당신은 에디터에서 “safe write”를 비활성화해야 합니다. </p>

<ul>
<li>VIM - set :set backupcopy=yes (see documentation)</li>
<li>IntelliJ - Settings ▶︎ System Settings ▶︎ Synchronization ▶︎ disable safe write (may differ in various IntelliJ IDEs, but you can still use the search feature)</li>
</ul>

<h2 id="toc_9">Proxy</h2>

<p>웹팩개발서버는 http-proxy-middleware 를 사용하여서 선택적으로 분리된거나 외부의 백엔드서버에 요청을 프록시 처리할 수 있습니다. 예제 설정은 다음과 같습니다. </p>

<div><pre><code class="language-none">proxy: {
  &#39;/api&#39;: {
    target: &#39;https://other-server.example.com&#39;,
    secure: false
  }
}

// In webpack.config.js
{
  devServer: {
    proxy: {
      &#39;/api&#39;: {
        target: &#39;https://other-server.example.com&#39;,
        secure: false
      }
    }
  }
}</code></pre></div>

<p>가능한 설정을 보고 싶다면 다음의 링크를 클릭하세요.  <a href="https://github.com/chimurai/http-proxy-middleware#options">http-proxy-middleware Options documentation</a> </p>

<p>몇가지 URL을 프록시하는 것은 다양한 설정에 유용할 수 있습니다. 하나의 예제는 로컬 개발서버에서 자바스크립트 파일과 다른 정적 자원들을 제공하지만 외부 개발서버에 요청을 날릴 때입니다.
다른 예제는 인증백엔드서버와 어플리케이션 백엔드 서버같은 두개의 나눠진 서버에 요청을 나눌 때입니다.</p>

<h3 id="toc_10">Bypass the Proxy (프록시 우회하기)</h3>

<p>(Added in v1.13.0) 프록시는 선택적으로 함수로 부터 반환되는 값에 기반하여 우회될 수 있습니다. 그 함수는 HTTP 요청과 응답, 주어진 프록시 옵션을 조사합니다. 이것은 반드시 false나 URL경로를 리턴하여서 요청을 프록시처리하는 것을 계속할 것인지 아닌지를 결정합니다. </p>

<p>예를 들어서 다음의 설정은 브라우저로부터 비롯된 요청을 프록시하지 않습니다. 이것은 <code>historyApiFallback</code> 옵션과 비슷합니다. 브라우저 요청은 평소대로 HTML 파일들을 받고, API에 대한 요청은 백엔드서버로 프록시 요청될 것입니다.</p>

<div><pre><code class="language-none">proxy: {
  &#39;/some/path&#39;: {
    target: &#39;https://other-server.example.com&#39;,
    secure: false,
    bypass: function(req, res, proxyOptions) {
      if (req.headers.accept.indexOf(&#39;html&#39;) !== -1) {
        console.log(&#39;Skipping proxy for browser request.&#39;);
        return &#39;/index.html&#39;;
    }
  }
}</code></pre></div>

<h4 id="toc_11">Rewriting URLs of proxy request 프록시 요청에 대하여 URL들을 Rewriting하기</h4>

<p>(Added in v1.15.0)  프록시에 대한 요청은 선택적으로 제공된 함수에 의하여 다시 쓰여질 수 있습니다. 함수는 HTTP 요청을 조사하고 변경할 수 있습니다. 예를 들어서 다음과 같은 설정은 URL의 시작부분에 /api부분을 삭제하면서 HTTP요청을 다시 쓸 수 있습니다. </p>

<div><pre><code class="language-none">proxy: {
  &#39;/api&#39;: {
    target: &#39;https://other-server.example.com&#39;,
    pathRewrite: {&#39;^/api&#39; : &#39;&#39;}
  }
}</code></pre></div>

<p><code>pathRewrite</code>는 http-proxy-middleware의 특징입니다. 더 많은 설정을 원하신다면, 해당 부분 문서를 확인하세요. </p>

<h4 id="toc_12">Proxying local virtual hosts 로컬 가상호스트 프록시하기</h4>

<p><code>http-proxy-middleware</code> 가 미리 로컬 호스트 네임을 로컬호스트에 해석하는 것처럼 보이므로 당신은 프록시 요청을 수정하기 위하여 다음의 설정이 필요할 것입니다.</p>

<div><pre><code class="language-none">var server = new webpackDevServer(compiler, {
  quiet: false,
  stats: { colors: true },
  proxy: {
    &quot;/api&quot;: {
      &quot;target&quot;: {
        &quot;host&quot;: &quot;action-js.dev&quot;,
        &quot;protocol&quot;: &#39;http:&#39;,
        &quot;port&quot;: 80
      },
      ignorePath: true,
      changeOrigin: true,
      secure: false
    }
  }
});
server.listen(8080);</code></pre></div>

<h4 id="toc_13">웹팩 개발서버 CLI</h4>

<div><pre><code class="language-none">$ webpack-dev-server &lt;entry&gt;</code></pre></div>

<p>모든 웹팩 CLI 옵션들은 웹팩 개발서버 CLI에도 유효합니다. 그러나 웹팩개발서버에는 <code>&lt;output&gt;</code> 기본 아규먼트가 존재하지 않습니다. 웹팩개발서버 CLI를 위한 <code>webpack.config.js</code> (혹은  파일로 전달되는 <code>--config</code> 옵션 ) 또한 적용될 수 있습니다. </p>

<p>여기 몇가지 옵션들이 있습니다 : </p>

<ul>
<li><code>--content-base</code> <file/directory/url/port>: 내용들을 위한 기본 경로입니다. base path for the content.</li>
<li><code>--quiet</code>: 콘솔에 어떠한 것도 출력하지 않습니다. don’t output anything to the console.</li>
<li><code>--no-info</code>: 지루한 정보들은 나타내지 않습니다. suppress boring information.</li>
<li><code>--colors</code>: 몇가지 색상을 더하여 출력합니다. add some colors to the output.</li>
<li><code>--no-colors</code>: 색상을 사용하지 않고 출력합니다.  don’t use colors in the output.</li>
<li><code>--compress</code>: gzip압축을 사용합니다. use gzip compression.</li>
<li><code>--host</code> <hostname/ip>: 모든 호스트에 호스트네임이나 IP 0.0.0.0 을바인딩 시킵니다. hostname or IP. 0.0.0.0 binds to all hosts.</li>
<li><code>--port</code> <number>: 포트 port.</li>
<li><code>--inline</code>: 번들에 웹팩개발서버런타임을 내장시킵니다. embed the webpack-dev-server runtime into the bundle.</li>
<li><code>--hot</code>: 핫모듈리대체플러그인을 추가하고 서버를 핫모드로 변경합니다. </li>
</ul>

<p>참고 : 핫모듈대체플러그인을 두번 추가할 수가 없습니다. </p>

<ul>
<li><code>--hot --inline</code> 또한 <code>webpack/hot/dev-server</code>엔트리를 추가합니다. </li>
<li><code>--public</code>: 클라이언트를 위하여 --inline모드에서 사용되는 host와 포트를 오버라이드합니다. (VM이나 도커에 유용합니다 ) </li>
<li><code>--lazy</code>:  요청에 대하여 감시하지 않고, 컴파일하지도 않습니다( --hot과 같이 사용할 수 없습니다) .</li>
<li><code>--https</code>: HTTPS프로토콜에서 웹팩개발서버를 제공합니다. 요청을 처리할때 직접 서명된 증명서(self-signed certificate)를 포함합니다. </li>
<li><code>--cert, --cacert, --key</code>: 증명서파일에 대한 경로 .</li>
<li><code>--open</code>:  기본프라우저에서 url을 엽니다. (웹팩개발서버가 2.0 버젼 이상이어야 합니다.) </li>
<li><code>--history-api-fallback</code>: 히스토리 API fallback에 대한 지원을 활성화합니다. </li>
</ul>

<h2 id="toc_14">추가적인 설정 옵션</h2>

<p>CLI 를 사용할 때, 핵심 개발서버 아래의 설정 파일에서 웹팩개발서버 옵션들을 가지는 것이 가능합니다. CLI인자로 
전해지는 옵션들은 설정파일의 옵션들을 오버라이드합니다. 개발서버를 위한 옵션들은 다음 섹션에서 보겠습니다. </p>

<h4 id="toc_15">예제</h4>

<div><pre><code class="language-none">module.exports = {
  // ...
  devServer: {
    hot: true
  }
}</code></pre></div>

<h3 id="toc_16">API</h3>

<div><pre><code class="language-none">var WebpackDevServer = require(&quot;webpack-dev-server&quot;);
var webpack = require(&quot;webpack&quot;);

var compiler = webpack({
  // configuration 설정
});
var server = new WebpackDevServer(compiler, {
  // webpack-dev-server options 웹팩 개발 서버 옵션

  contentBase: &quot;/path/to/directory&quot;,
  // Can also be an array, or: contentBase: &quot;http://localhost/&quot;,
  // 배열이나 contentBase를 사용할 수 있다.

  hot: true,
  // Enable special support for Hot Module Replacement
  // Page is no longer updated, but a &quot;webpackHotUpdate&quot; message is send to the content
  // Use &quot;webpack/hot/dev-server&quot; as additional module in your entry point
  // Note: this does _not_ add the `HotModuleReplacementPlugin` like the CLI option does. 
  // 핫모듈대체를 위한 특별 지원 활성화

  // Set this as true if you want to access dev server from arbitrary url.
  // This is handy if you are using a html5 router.
  // 만약 임의의 URL부터 개발서버로 접근하기를 원한다면 true로 설정
  // 만약 html5 라우터를 사용한다면 편리합니다. 
  historyApiFallback: false,

  // Set this if you want to enable gzip compression for assets
  // 자원들에 관해서 gzip압축을 원한다면 true
  compress: true,

  // Set this if you want webpack-dev-server to delegate a single path to an arbitrary server.
  // Use &quot;**&quot; to proxy all paths to the specified server.
  // This is useful if you want to get rid of &#39;http://localhost:8080/&#39; in script[src],
  // and has many other use cases (see https://github.com/webpack/webpack-dev-server/pull/127 ).
  // 만약 웹팩개발서버가 임의의 서버로 단일 경로를 위임하고자 한다면 여기를 설정
  // 지정된 서버에 모든 경로를 프록시 처리하려면 ** 를 사용
  // script에서 http://localhost:8080을 제거 하고 싶을 때 유용합니다. 
  // 이밖에도 많은 사용 경우가 있습니다. 
  proxy: {
    &quot;**&quot;: &quot;http://localhost:9090&quot;
  },

  setup: function(app) {
    // Here you can access the Express app object and add your own custom middleware to it.
    // For example, to define custom handlers for some paths:
    // app.get(&#39;/some/path&#39;, function(req, res) {
    //   res.json({ custom: &#39;response&#39; });
    // });
    // 여기서 당신은 익스프레스 앱 객체를 접근할 수 있고 당신의 커스텀 미들웨어를 해당 앱객체에 추가할 수 있습니다.
    // 예를 들어서 어떤 경로들에 대해서 커스텀 핸들러를 정의할 수가 있습니다. 
  },

  // pass [static options](http://expressjs.com/en/4x/api.html#express.static) to inner express server
  // 정적 옵션들
  staticOptions: {
  },

  // webpack-dev-middleware options
  // 웹팩개발미들웨어 옵션들
  quiet: false,
  noInfo: false,
  lazy: true,
  filename: &quot;bundle.js&quot;,
  watchOptions: {
    aggregateTimeout: 300,
    poll: 1000
  },
  // It&#39;s a required option.
  // 필요한 옵션
  publicPath: &quot;/assets/&quot;,
  headers: { &quot;X-Custom-Header&quot;: &quot;yes&quot; },
  stats: { colors: true }
});
server.listen(8080, &quot;localhost&quot;, function() {});
// server.close();</code></pre></div>

<p>미들웨어 옵션들에 대해서 알고 싶다면 여기를 보자 <a href="https://webpack.github.io/docs/webpack-dev-middleware.html">webpack-dev-middleware</a></p>

<p>웹팩설정이 웹팩개발서버 API에 전달되지 않기 때문에, 웹팩 설정에서 <code>devServer</code>옵션 은 이러한 경우 사용되지 않습니다. 또한 <code>WebpackDevServer</code> API 에 대하여 인라인 모드는 없습니다. </p>

<p><code>&lt;script src=&quot;http://localhost:8080/webpack-dev-server.js&quot;&gt;&lt;/script&gt;</code> 가 HTML페이지에 직접 입력되어야 합니다.</p>

<h2 id="toc_17">The historyApiFallback option</h2>

<p>만약 당신이 HTML5 히스토리 API를 사용한다면 당신은 아마 404 응답을 대신하여 index.html을 제공하기를 원할 지도 모르는데 이것은 <code>historyApiFallback: true</code>를 설정함으로써 이뤄질 수가 있습니다. 그러나 만약 당신이 웹팩 설정에서 <code>output.publicPath</code>를 수정한다면 당신은 리다이렉트될 URL을 설정할 필요가 있을 겁니다. 이것은 <code>historyApiFallback.index</code> 옵션을 통하여 이뤄집니다.</p>

<div><pre><code class="language-none">// output.publicPath: &#39;/foo-app/&#39;
historyApiFallback: {
  index: &#39;/foo-app/&#39;
}</code></pre></div>

<p>rewrites를 사용하여서, 정적 페이지들을 제공하기 위한 이러한 기능들이 사용될 수 있습니다. </p>

<div><pre><code class="language-none">historyApiFallback: {
    rewrites: [
        // shows views/landing.html as the landing page
        { from: /^\/$/, to: &#39;/views/landing.html&#39; },
        // shows views/subpage.html for all routes starting with /subpage
        { from: /^\/subpage/, to: &#39;/views/subpage.html&#39; },
        // shows views/404.html on all other pages
        { from: /./, to: &#39;/views/404.html&#39; },
    ],
},</code></pre></div>

<h2 id="toc_18">존재하는 서버끼리 결합하기</h2>

<p>당신은 아마 개발단계에서 백엔드서버나 백엔드목서버를 사용하기를 원할지도 모릅니다. 당신은 webpack-dev-server 를 백엔드로 사용하여서는 안됩니다. 웹팩개발서버는 오직 웹팩된 정적자원들을 제공하기 위한 목적입니다.</p>

<p>당신은 웹팩개발서버와 백엔드 서버 두 가지를 운영할 수가 있습니다. </p>

<p>이러한 경우 당신은 (HTML페이지가 동작하고있더라도)웹팩으로 생성된 자원에게 요청들이 백엔드서버로 가야한다고 가르쳐줄 필요가 있습니다. 다른 쪽면에서는 백엔드서버쪽의 생성된 HTML들이 웹팩개발서버에 있는 자원들을 가리키게 해야 합니다. (맞나?) 추가적으로 웹팩개발서버와 개발서버 런타임간에 연결하여서 다시 컴파일 할 시에 다시 불러오기 트리거를 발생시켜야 합니다. </p>

<p>웹팩에게 웹팩개발서버에 대한 요청을 만들게 하기 위해 (chunk loading 이나 HMR), 당신은 <code>output.publicPath</code>옵션에서 full URL을 제공할 필요가 있습니다. </p>

<p>웹팩개발서버와 그것의 런타임간의 커넥션을 만들기 위해 <code>--inline</code>과 함께 인라인모드를 사용하세요. 웹팩개발서버 CLI는 자동적으로 웹소켓 커넥션을 만들 수 있는 엔트리 포인트를 포함하게 될 것입니다. (당신은 또한 iframe모드를 사용할 수 있습니다. 만약 당신이 웹팩개발서버의 <code>--content-base</code>에서 백엔드 서버를 지정한다면 ) 만약 당신이 백엔드 서버와의 커넥션을 원한다면 당신은 아이프레임 모드를 사용하면 됩니다. </p>

<p>당신이 인라인 모드를 사용하기를 원한다면, 단지 백엔드 서버URL을 웹브라우저에다가 치면 됩니다. ( 만약 당신이 아이프레임모드를 사용한다면 웹팩개발서버의 접두된 URL /webpack-dev-server/ 을 치면 됩니다 ) </p>

<p>요약과 예제입니다. (여기는 이만.. )</p>

<p>webpack-dev-server on port 8080.
backend server on port 9090.
generate HTML pages with <script src="http://localhost:8080/assets/bundle.js">.
webpack configuration with output.publicPath = &quot;http://localhost:8080/assets/&quot;.
when compiling files for production, use --output-public-path /assets/.
inline mode:
--inline.
open http://localhost:9090.
or iframe mode:
webpack-dev-server contentBase = &quot;http://localhost:9090/&quot; (--content-base).
open http://localhost:8080/webpack-dev-server/.
Or use the proxy option…</p>




</body>

</html>
